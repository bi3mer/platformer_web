class C{scenes={};registerScene(X,f){if(this.scenes[X]===void 0)this.scenes[X]=f;else console.error(`Key "${X}" for scene already exists! Scene not added to SceneManager.`)}getScene(X){return this.scenes[X]}}class G{changeScene;onExit(){this.changeScene=void 0,this._onExit()}}var B="main menu",b="game";class P extends G{constructor(){super()}onEnter(){}update(X){this.changeScene=b}render(){}_onExit(){}}var x=["-------------------------------------------","-------------------------------------------","-------------------------------------------","-------------------------------------------","---X-E-X-----------------------------------","---XXXXX----------------------X------------","--------------------------o---X------------","--------------------------X---X------------","X---------------------0-------X------------","X--------------------XX-------X------------","XXX--------------o------------X----------o-","XXX---X---------XXX-----------X------------","X----XX-----------------------XX-----X-----","X---XXX---------E-------------XXX-E-XX-----","XXXXXXX---XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"];var k=720,j=480,z=32,h=15,A=17,W=20,d=30,g=0.625,M=0.9375,i=31,_=31,I=0.96875,m=0.96875,K=16,o=16,E=0.5,c=0.5,y=25,r=15,n=0.78125,t=0.46875;class l{startCol=0;endCol=0;offsetX=0;colsPerScreen=Math.ceil(k/z);update(X){const f=X-this.colsPerScreen/2;this.startCol=Math.max(0,Math.floor(f)),this.endCol=this.startCol+this.colsPerScreen,this.offsetX=-f*z+this.startCol*z}columnToScreen(X){return(X-this.startCol)*z+this.offsetX}rowToScreen(X){return X*z}}class V{x;y;constructor(X,f){this.x=X,this.y=f}copy(){return new V(this.x,this.y)}zero(){this.x=0,this.y=0}equals(X){return this.x==X.x&&this.y==X.y}add(X){return new V(this.x+X.x,this.y+X.y)}addInPlace(X){this.x+=X.x,this.y+=X.y}subtract(X){return new V(this.x-X.x,this.y-X.y)}subtractInPlace(X){this.x-=X.x,this.y-=X.y}scalarAdd(X){this.x+=X,this.y+=X}scalarSubtract(X){this.x-=X,this.y-=X}scalarMultiply(X){return new V(this.x*X,this.y*X)}scalarMultiplyInPlace(X){this.x*=X,this.y*=X}dot(X){return this.x*X.x+this.y+X.y}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}}function a(X,f,F,$){const{x:q,y:U}=X,Z=q+f.x,fX=U+f.y,H=F.x,T=F.y,FX=H+$.x,qX=T+$.y;return q<FX&&Z>H&&U<qX&&fX>T}class w{pos;size;type;dead=!1;velocity=new V(0,0);gravity=new V(0,100);constructor(X,f,F,$,q){this.pos=new V(X,f),this.size=new V(F,$),this.type=q}collision(X){if(a(this.pos,this.size,X.pos,X.size))this.handleCollision(X),X.handleCollision(this)}physicsUpdate(X){this.velocity.addInPlace(this.gravity.scalarMultiply(X)),this.velocity.y=Math.min(this.velocity.y,30),this.pos.addInPlace(this.velocity.scalarMultiply(X))}}var L=0,D=1,R=2,u=3;var J;(function(Q){Q[Q["LEFT"]=0]="LEFT";Q[Q["RIGHT"]=1]="RIGHT";Q[Q["DOWN"]=2]="DOWN";Q[Q["UP"]=3]="UP";Q[Q["A"]=4]="A";Q[Q["D"]=5]="D";Q[Q["E"]=6]="E";Q[Q["G"]=7]="G";Q[Q["H"]=8]="H";Q[Q["I"]=9]="I";Q[Q["Q"]=10]="Q";Q[Q["R"]=11]="R";Q[Q["S"]=12]="S";Q[Q["W"]=13]="W";Q[Q["SPACE"]=14]="SPACE";Q[Q["ESCAPE"]=15]="ESCAPE";Q[Q["ENTER"]=16]="ENTER";Q[Q["INVALID"]=17]="INVALID"})(J||(J={}));class v{static _keys=[];static init(){for(let X=0;X<Object.keys(J).length;++X)v._keys.push(!1);window.addEventListener("keydown",v.onKeyDown),window.addEventListener("keyup",v.onKeyUp)}static isKeyDown(...X){const f=X.length;for(let F=0;F<f;++F)if(v._keys[X[F]])return!0;return!1}static keyStrToKey(X){switch(X){case"Down":case"ArrowDown":return J.DOWN;case"Up":case"ArrowUp":return J.UP;case"Right":case"ArrowRight":return J.RIGHT;case"Left":case"ArrowLeft":return J.LEFT;case" ":case"Space":return J.SPACE;case"Escape":return J.ESCAPE;case"a":case"A":return J.A;case"e":case"E":return J.E;case"s":case"S":return J.S;case"d":case"D":return J.D;case"w":case"W":return J.W;case"r":case"R":return J.R;case"q":case"Q":return J.Q;case"g":case"G":return J.G;case"h":case"H":return J.H;case"i":case"I":return J.I;case"Enter":return J.ENTER;default:return console.warn(`Unhandled key: ${X}.`),J.INVALID}}static onKeyDown(X){const f=v.keyStrToKey(X.key);if(v._keys[f]=!0,f==J.DOWN||f==J.UP||f==J.LEFT||f==J.RIGHT)X.preventDefault();return!1}static onKeyUp(X){return v._keys[v.keyStrToKey(X.key)]=!1,!1}static clear(){for(let X=0;X<v._keys.length;++X)v._keys[X]=!1}static onMouseMove(X){}}var e=6,XX=8,QX=0.4;class Y extends w{movingRight=!1;movingLeft=!1;moveMod=0;jumpTime=0;coinsCollected=0;constructor(X,f){super(X,f,g,M,L)}update(X){if(this.velocity.x=0,v.isKeyDown(J.D,J.RIGHT))this.movingRight=!0,this.velocity.x=e,this.moveMod=Math.min(XX,this.moveMod+X);if(v.isKeyDown(J.A,J.LEFT))if(this.movingRight)this.movingRight=!1,this.velocity.x=0;else this.movingLeft=!0,this.velocity.x=-e,this.moveMod=Math.min(XX,this.moveMod+X);if(this.jumpTime<QX&&v.isKeyDown(J.SPACE)){if(this.jumpTime===0)this.velocity.y=-15;else if(this.jumpTime<0.2)this.velocity.y-=2;this.jumpTime+=X}if(this.pos.y>A)this.dead=!0,console.log("Player fell...")}handleCollision(X){switch(X.type){case D:{const f=this.pos.add(this.size.scalarMultiply(0.5)),F=X.pos.add(X.size.scalarMultiply(0.5)),$=f.subtract(F);this.size.add(X.size).scalarMultiply(0.5);const U=Math.abs(Math.atan($.y/$.x));if(!(U<0.96&&U>0.698)&&Math.abs($.x/this.size.x)>Math.abs($.y/this.size.y))if($.x<0)this.pos.x=X.pos.x-this.size.x;else this.pos.x=X.pos.x+X.size.x;else if($.y>0)this.pos.y=X.pos.y+this.size.y;else this.pos.y=X.pos.y-this.size.y,this.velocity.y=0,this.jumpTime=0;break}case R:{++this.coinsCollected;break}case u:{this.dead=!0,console.log("Ran into an enemy! :/");break}default:{console.warn(`Player unhandled collision type: ${X.type}.`);break}}}render(X,f){X.fillStyle="rgba(150,150,255,1)";const F=f.columnToScreen(this.pos.x),$=f.rowToScreen(this.pos.y);if(this.movingRight){let q=new Path2D;q.moveTo(F,$),q.lineTo(F-this.moveMod,$+d),q.lineTo(F+W-this.moveMod,$+d),q.lineTo(F+W,$),q.closePath(),X.fill(q,"evenodd"),this.movingRight=!1}else if(this.movingLeft){let q=new Path2D;q.moveTo(F,$),q.lineTo(F+this.moveMod,$+d),q.lineTo(F+W+this.moveMod,$+d),q.lineTo(F+W,$),q.closePath(),X.fill(q,"evenodd"),this.movingLeft=!1}else X.fillRect(F,$,W,d)}}class O extends w{constructor(X,f){super(X,f,I,m,D)}update(X){}handleCollision(X){}render(X,f){X.strokeStyle="white",X.strokeRect(f.columnToScreen(this.pos.x),f.rowToScreen(this.pos.y),i,_)}}class s extends w{minY;maxY;yMod;constructor(X,f){super(X+0.25,f+0.25,E,c,R);this.gravity.y=0,this.yMod=Math.random()*0.5,this.maxY=f+0.3,this.minY=f+0.15,this.velocity.y=this.yMod}update(X){if(this.pos.y>=this.maxY)this.velocity.y=-this.yMod;else if(this.pos.y<=this.minY)this.velocity.y=this.yMod}handleCollision(X){if(X.type===L)this.dead=!0}render(X,f){X.fillStyle="yellow",X.fillRect(f.columnToScreen(this.pos.x),f.rowToScreen(this.pos.y),K,o)}}class N extends w{constructor(X,f){super(X,f+0.1,n,t,u);this.velocity.x=3,this.gravity.y=0}update(X){if(this.pos.y>A)this.dead=!0}handleCollision(X){if(X.type===D)this.velocity.x*=-1}render(X,f){X.fillStyle="red",X.fillRect(f.columnToScreen(this.pos.x),f.rowToScreen(this.pos.y),y,r)}}class S extends G{ctx;camera;numCoins;staticEntities;dynamicEntities;constructor(X){super();this.ctx=X,this.camera=new l}onEnter(){this.dynamicEntities=[],this.staticEntities=[],this.numCoins=0,this.dynamicEntities.push(new Y(2,12));const X=x,f=X.length;if(f!==h){console.error("Level should have 15 rows!");return}const F=X[0].length;for(let $=0;$<f;++$){const q=X[$];if(F!==q.length){console.error(`Every row in the level should have the same number of columns! (${F} !== ${q.length}).`);return}for(let U=0;U<F;++U)if(q[U]==="X"){const Z=new O(U,$);this.staticEntities.push(Z)}else if(q[U]==="o"){const Z=new s(U,$);++this.numCoins,this.dynamicEntities.push(Z)}else if(q[U]==="E"){const Z=new N(U,$);this.dynamicEntities.push(Z)}}}update(X){let f=this.dynamicEntities.length,F=0;for(;F<f;++F)if(this.dynamicEntities[F].dead)this.dynamicEntities.splice(F,1),--f,--F;const $=this.staticEntities.length;let q;for(F=0;F<f;++F){const Z=this.dynamicEntities[F];Z.update(X),Z.physicsUpdate(X);for(q=F+1;q<f;++q)Z.collision(this.dynamicEntities[q]);for(q=0;q<$;++q)Z.collision(this.staticEntities[q])}const U=this.dynamicEntities[0];if(U.coinsCollected>=this.numCoins)console.log("Player won!"),this.changeScene=B;if(U.dead)this.changeScene=B}render(){this.ctx.clearRect(0,0,k,j),this.camera.update(this.dynamicEntities[0].pos.x);let X=this.staticEntities.length,f=0;for(;f<X;++f)this.staticEntities[f].render(this.ctx,this.camera);X=this.dynamicEntities.length;for(f=0;f<X;++f)this.dynamicEntities[f].render(this.ctx,this.camera)}_onExit(){}}class p{canvas;ctx;currentScene;sceneManager;constructor(){this.canvas=document.createElement("canvas"),this.canvas.setAttribute("id","canvas"),this.canvas.width=k,this.canvas.height=j,this.ctx=this.canvas.getContext("2d"),document.getElementById("game").appendChild(this.canvas),this.sceneManager=new C,this.sceneManager.registerScene(B,new P),this.sceneManager.registerScene(b,new S(this.ctx)),this.currentScene=this.sceneManager.getScene(B),this.currentScene.onEnter()}start(){let X=0;const f=(F)=>{const $=Math.min(0.05,(F-X)/1000);X=F,this.currentScene.update($),this.currentScene.render();const q=this.currentScene.changeScene;if(q!==void 0)this.currentScene.onExit(),this.currentScene=this.sceneManager.getScene(q),this.currentScene.onEnter();window.requestAnimationFrame(f)};window.requestAnimationFrame(f)}}window.addEventListener("load",()=>{v.init(),new p().start()});
